{{ define "main" }}
<main class="main full-width">
  <header class="page-header">
    <h1>标签云</h1>
  </header>

  <div id="tag-cloud">
    <div id="tags"></div>
  </div>

  <div id="post-list">
    <p>加载文章中...</p>
  </div>
  
  <div id="pagination" style="text-align:center;margin-top:1rem;"></div>
</main>

<script>
const perPage = {{ .Site.Params.pagination.pagerSize | default 7 }};
let currentPage = 1;
let allPosts = [];
let selectedTags = new Set();

// 标签 → hue 映射表
const tagHueMap = {};

// 根据标签生成固定颜色
function getTagHue(tag) {
  if (!tagHueMap[tag]) {
    let hash = 0;
    for (let i = 0; i < tag.length; i++) {
      const code = tag.charCodeAt(i);
      hash = (hash << 5) ^ (hash >> 2) ^ code; // 更好的位混合
    }
    tagHueMap[tag] = Math.abs(hash) % 3600 / 10.0; // 0~359度
  }
  return tagHueMap[tag];
}

// 初始化标签云和文章
async function initTags() {
  try {
    const lang = window.location.pathname.split('/')[1];
    const jsonPath = (lang && lang.length === 2) ? `/${lang}/index.json` : '/index.json';
    const res = await fetch(jsonPath);
    // const res = await fetch('/index.json');
    allPosts = await res.json();
    renderTags();

    // 读取 URL 参数并 decode
    const urlParams = new URLSearchParams(window.location.search);
    const initialTags = urlParams.get('t');
    if (initialTags) {
      initialTags.split(',').map(decodeURIComponent).forEach(tag => selectedTags.add(tag));
      updateTagStyles();
    }

    renderPosts(); // 默认显示所有有标签文章
  } catch (e) {
    console.log(e);
    document.getElementById('post-list').innerHTML = '无法加载文章列表。';
  }
}

// 渲染标签云
function renderTags() {
  const tags = [...new Set(allPosts.flatMap(p => p.tags || []))].sort();
  const container = document.getElementById('tags');
  container.innerHTML = tags.map(tag => {

    const hue = getTagHue(tag);
    return `<button class="tag-btn" data-tag="${tag}" style="--hue:${hue}" onclick="toggleTag('${tag}')">${tag}</button>`;
    // return `<button class="tag-btn" data-tag="${tag}" onclick="toggleTag('${tag}')">${tag}</button>`;
  }).join('');
}


// 标签点击切换
function toggleTag(tag) {
  if (selectedTags.has(tag)) selectedTags.delete(tag);
  else selectedTags.add(tag);
  
  // 切换标签后重置当前页为第一页
  currentPage = 1;

  updateTagStyles();
  renderPosts();
  updateURL();
}

// 更新标签样式（选中效果）
function updateTagStyles() {
  document.querySelectorAll('.tag-btn').forEach(btn => {
    btn.classList.toggle('selected', selectedTags.has(btn.dataset.tag));
  });
}

// 更新 URL
function updateURL() {
  const url = new URL(window.location);
  if (selectedTags.size > 0) {
    url.searchParams.set('t', [...selectedTags].map(encodeURIComponent).join(','));
  } else {
    url.searchParams.delete('t');
  }
  window.history.replaceState(null, '', url);
}

// 渲染文章列表

function renderPosts() {
  const container = document.getElementById('post-list');

  const filtered = selectedTags.size === 0
    ? allPosts.filter(p => p.tags && p.tags.length > 0)
    : allPosts.filter(p =>
        [...selectedTags].every(tag => (p.tags || []).includes(tag))
      );

  if (filtered.length === 0) {
    container.innerHTML = '<p>没有匹配的文章。</p>';
    document.getElementById('pagination').innerHTML = '';
    return;
  }

  const totalPages = Math.ceil(filtered.length / perPage);
  const start = (currentPage - 1) * perPage;
  const pagePosts = filtered.slice(start, start + perPage);

  container.innerHTML = pagePosts.map(p => {
    const artHue = Math.floor(Math.random() * 360);
    return `
      <article style="--hue:${artHue}" data-tags="${(p.tags||[]).join(',')}">
        <a href="${p.permalink}">${p.title}</a>
        <small style="color: var(--stack-text-muted, #777);">(${p.date})</small>
        <div class="post-tags">
          ${(p.tags||[]).map(tag => {
            const hue = getTagHue(tag);
            return `<span class="post-tag" data-tag="${tag}" style="--hue:${hue}" onclick="toggleTag('${tag}')">${tag}</span>`;
          }).join(' ')}
        </div>
      </article>
    `;
  }).join('');

  renderPagination(totalPages);
}

function renderPagination(totalPages) {
  const pagination = document.getElementById('pagination');
  if (!pagination) return;

  // 没有分页或只有一页
  if (totalPages <= 1) {
    pagination.innerHTML = '';
    return;
  }

  const maxButtons = 7; // 最多显示7个页码按钮（含省略）
  const pages = [];
  const addBtn = (page, label = page) => {
    pages.push(`<button class="page-btn ${page === currentPage ? 'active' : ''}" 
      onclick="gotoPage(${page})">${label}</button>`);
  };

  // 上一页
  if (currentPage > 1)
    addBtn(currentPage - 1, '«');

  // 计算页码范围
  let start = Math.max(1, currentPage - 2);
  let end = Math.min(totalPages, currentPage + 2);

  // 调整范围，确保显示数量不超过 maxButtons
  if (currentPage <= 3) end = Math.min(totalPages, maxButtons - 2);
  if (currentPage >= totalPages - 2) start = Math.max(1, totalPages - (maxButtons - 3));

  // 头部省略号
  if (start > 1) {
    addBtn(1);
    if (start > 2) pages.push(`<span class="ellipsis">…</span>`);
  }

  // 中间页码
  for (let i = start; i <= end; i++) addBtn(i);

  // 尾部省略号
  if (end < totalPages) {
    if (end < totalPages - 1) pages.push(`<span class="ellipsis">…</span>`);
    addBtn(totalPages);
  }

  // 下一页
  if (currentPage < totalPages)
    addBtn(currentPage + 1, '»');

  pagination.innerHTML = pages.join(' ');
}


function gotoPage(page) {
  currentPage = page;
  renderPosts();
  window.scrollTo({ top: 0, behavior: 'smooth' });
}

function initCenterGlow() {
  document.querySelectorAll('.tag-btn, #post-list article').forEach(el => {
    const rect = el.getBoundingClientRect();
    el.style.setProperty('--x', `${rect.width / 2}px`);
    el.style.setProperty('--y', `${rect.height / 2}px`);
    el.style.setProperty('--radius-x', `25vw`);
    el.style.setProperty('--radius-y', `22vw`);
  });
}


// 初始化
initTags();
initCenterGlow();   // 初始化光晕

// 鼠标跟随流动光晕
document.addEventListener('mousemove', e => {
  const { innerWidth, innerHeight } = window;
  const xRatio = e.clientX / innerWidth;
  const yRatio = e.clientY / innerHeight;

  // 根据位置动态调整鼠标光晕大小
  const radiusX = 25 + Math.abs(xRatio - 0.5) * 20;
  const radiusY = 22 + Math.abs(yRatio - 0.5) * 18;

  // 动态为每个元素添加鼠标光晕的偏移效果
  document.querySelectorAll('.tag-btn, #post-list article').forEach(el => {
    const rect = el.getBoundingClientRect();
    const offsetX = e.clientX - rect.left;
    const offsetY = e.clientY - rect.top;

    // 用CSS变量保存鼠标光晕
    el.style.setProperty('--mx', `${offsetX}px`);
    el.style.setProperty('--my', `${offsetY}px`);
    el.style.setProperty('--radius-x', `${radiusX}vw`);
    el.style.setProperty('--radius-y', `${radiusY}vw`);
  });
});




</script>

{{ partial "footer/footer.html" }}

{{ end }}


